'''
背包问题框架
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 计算(选择1，选择2...)
初始化
dp[0][..] = 0
dp[..][0] = 1
状态1 通常是个数也就是物品个数
状态2 通常是物品重量
'''
def pack0(N, V, c, w):
    '''
    0 1背包问题
    :param N: N件物品
    :param V: 一个容量为V的背包
    :param c: 第i件物品的费用是c[i]
    :param w: 价值是w[i]
    :return: 每种物品都有只有一件可用，求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
    '''

    '''
    方法一
    “将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。
    如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；
    如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，
    此时能获得的最大价值就是f [i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。
    '''
    f = [[0 for i in range(V)] for j in range(V)]
    for i in range(N):
        for v in range(c[i], V):
            # 第 i 件物品 放不放 只和前i-1件物品放不放相关
            # f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值
            f[i][v] = max(f[i-1][v], f[i-1][v-c[i]]+w[i])
    '''
    方法二
    状态压缩，按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。
    换句话说，这正是为了保证每件物品只选一次，
    保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]
    '''
    f = [0 for i in range(V)]
    for i in range(N):
        for v in range(V, c[i]):
            f[v] = max(f[v], f[v-c[i]]+w[i])

def pack1(N, V, c, w):
    '''
    完全背包问题
    :param N: N件物品
    :param V: 一个容量为V的背包
    :param c: 第i件物品的费用是c[i]
    :param w: 价值是w[i]
    :return: 每种物品都有无限件可用，求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
    '''
    #
    f = [[0 for i in range(V)] for j in range(V)]
    for i in range(N):
        for v in range(c[i], V):
            # 第 i 件物品 放不放 只和前i-1件物品放不放相关
            # f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值
            for k in range(v//c[i]):
                # 此处需要加入一个k值，k最多的取多少件
                f[i][v] = max(f[i-1][v], f[i-1][v-c[i]]+w[i]*k)

    #状态压缩优化
    f = {}
    for i in range(N):
        #完全背包的特点恰是每种物品可选无限件，
        # 所以在考虑“加选一件第i种物品”这种策略时，
        # 却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。
        for v in range(0, V):
            f[v] = max(f[v], f[v-c[i]]+w[i])

def pack2(N, V, c, w, n):
    '''
    多重背包问题
    :param N: N件物品
    :param V: 一个容量为V的背包
    :param c: 第i件物品的费用是c[i]
    :param w: 价值是w[i]
    :return: 第i种物品最多有n[i]件可用，求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
    '''
    #解法1 普通的完全背包，限制件数
    f = [[0 for i in range(V)] for j in range(V)]
    for i in range(N):
        for v in range(c[i], V):
            # 第 i 件物品 放不放 只和前i-1件物品放不放相关
            # f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值
            for k in range(n[i]):
                # 此处需要加入一个k值，k最多的取 设定的次数 n[i]件
                f[i][v] = max(f[i-1][v], f[i-1][v-c[i]]+w[i]*k)

    # 解法2 转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，
    # 则得到了物品数为Σn[i]的01背包问题，直接求解，复杂度仍然是O(V*Σn[i])。
